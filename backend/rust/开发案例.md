# å¼€å‘æ¡ˆä¾‹
## 1ã€toto cli
:::tip ä¸‰æ–¹åº“
- clap: å‘½ä»¤è¡Œè§£æ
- dirs: è·å–ç”¨æˆ·ç›®å½•
:::

### 1.1ã€å®‰è£…ä¾èµ–
```shell
cargo add clap
cargo add dirs
```

### 1.2ã€cli.rs
```js
use clap::{Parser, Subcommand};

#[derive(Parser)]
#[clap(version, about)]
#[clap(propagate_version = true)]
pub struct Cli {
    #[clap(subcommand)]
    pub command: Commands,
}

#[derive(Debug, Subcommand)]
pub enum Commands {
    #[clap(about = "Show odo info.")]
    Info,

    #[clap(about = "Add a todo item.")]
    Add {
        #[clap(help = "The item content to add.")]
        content: Option<String>,
    },

    #[clap(about = "Remove a todo item.")]
    #[clap(visible_aliases = & ["rm"])]
    Remove {
        #[clap(help = "The item id to remove.")]
        id: Option<String>,
    },

    #[clap(about = "List all the todo items.")]
    #[clap(visible_aliases = & ["ls", "ll", "la"])]
    List,
}
```

### 1.3ã€commands.rs
```js
use std::io;
use crate::database::{Database, Record};

pub fn info() -> Result<(), io::Error> {
    println!("Todo is a simple todo list manager.");
    Ok(())
}

pub fn add(db: &mut Database, content: Option<String>) -> Result<(), io::Error> {
    if let Some(content) = content {
        let records = db.read_records();
        db.add_record(&Record {
            id: records.len() as u32 + 1,
            content: content.clone(),
        })?;
        println!("ğŸ“ Item added: {}", content);
        Ok(())
    } else {
        eprintln!("You need to specify the content of the todo item.");
        std::process::exit(1);
    }
}

pub fn remove(db: &mut Database, id: Option<String>) -> Result<(), io::Error> {
    if id.is_none() {
        println!("You need to specify the id of the todo item.");
        std::process::exit(1);
    }
    println!("Removing a todo item: {}", id.clone().unwrap());
    db.remove_record(id.unwrap().parse::<u32>().unwrap())?;
    println!(" âŒ Item removed!\n");
    Ok(())
}

pub fn list(db: &mut Database) -> Result<(), io::Error> {
    let records = db.read_records();
    if records.is_empty() {
        eprintln!("No records. You can add one with `todo add [content]`");
        std::process::exit(1);
    }
    for record in records {
        println!(" â¬œï¸ {}: {}", record.id, record.content);
    }
    Ok(())
}
```

### 1.4ã€database.rs
```js
use std::fs::{File, OpenOptions};
use std::io::{self, BufRead, BufReader, Seek, Write};
use crate::utils::{check_db_file, get_db_file_path};

pub struct Record {
    pub id: u32,
    pub content: String,
}

pub struct Database {
    file: File,
}

// è§£æè®°å½•
pub fn parse_record_line(line: &str) -> Record {
    let fields: Vec<&str> = line.split(',').collect();
    // å¤„ç†ç©ºè¡Œçš„æƒ…å†µ
    if fields.len() == 1 {
        return Record {
            id: 0,
            content: "".to_string(),
        };
    }
    let content = fields[1..].join(",");
    Record {
        id: fields[0].parse::<u32>().unwrap(),
        content,
    }
}

impl Database {
    pub fn open() -> Database {
        // å…ˆæ£€æŸ¥ db æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œä¸å­˜åœ¨å°±åˆ›å»º
        check_db_file().unwrap();
        // è·å–dbæ–‡ä»¶è·¯å¾„
        let db_file = get_db_file_path();
        let file = OpenOptions::new()
            .create(true)
            .read(true)
            .write(true)
            .open(db_file)
            .unwrap();
        Database { file }
    }

    pub fn add_record(&mut self, record: &Record) -> Result<(), io::Error> {
        let line = format!("{},{}", record.id, record.content);
        writeln!(self.file, "{}", line)
    }

    pub fn read_records(&mut self) -> Vec<Record> {
        let reader = BufReader::new(&self.file);
        reader
            .lines()
            .map_while(Result::ok)
            .filter(|line| !line.is_empty())
            .map(|line| parse_record_line(&line))
            .collect()
    }

    pub fn remove_record(&mut self, id: u32) -> Result<(), io::Error> {
        let reader = BufReader::new(&self.file);
        let mut lines = reader.lines().enumerate();
        // æ ¹æ®idæ‰¾å‡ºå¯¹åº”çš„è¡Œ
        let line = lines.find(|(_, line)| {
            let record = parse_record_line(line.as_ref().unwrap());
            record.id == id
        });
        match line {
            Some((i, _)) => {
                // è¿‡æ»¤æ‰å¯¹åº”çš„è¡Œï¼Œè¿™é‡Œä½¿ç”¨çš„å¯¹åº” api å¯ä»¥æŸ¥çœ‹ Rust æ ‡å‡†åº“
                let new_contents = lines
                    .filter(|(j, _)| *j != i)
                    .map(|(_, line)| line.unwrap())
                    .collect::<Vec<_>>()
                    .join("\n");
                // è¿™é‡Œä½¿ç”¨äº† std::io::Seekï¼Œéœ€è¦å¯¼å…¥
                self.file.seek(std::io::SeekFrom::Start(0)).unwrap();
                self.file.write_all(new_contents.as_bytes()).unwrap();
                self.file.set_len(new_contents.len() as u64).unwrap();
                // println!(" âŒ Item removed!\n");
                Ok(())
            }
            None => Err(io::Error::new(
              io::ErrorKind::Other,
              format!("No such record: {}", id),
          )),
        }
    }
}
```

### 1.5ã€utils.rs
```js
use std::{path, fs, io};
use dirs::home_dir;

pub const DB_FILE: &str = ".todo_db";

// è·å–dbæ–‡ä»¶è·¯å¾„
pub fn get_db_file_path() -> path::PathBuf {
  home_dir().map(|it| it.join(DB_FILE)).unwrap_or_default()
}

// æ£€æŸ¥dbæ–‡ä»¶æ˜¯å¦å­˜åœ¨
pub fn db_exists() -> bool {
  let dir = get_db_file_path();
  fs::metadata(&dir).is_ok()
}

// åˆ›å»ºdb
pub fn create_db_file() -> io::Result<()> {
  let dir = get_db_file_path();
  fs::File::create(dir)?;
  Ok(())
}

// æ£€æŸ¥dbæ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œä¸å­˜åœ¨å°±åˆ›å»º
pub fn check_db_file() -> io::Result<()> {
  if !db_exists() {
    create_db_file()?;
  }
  Ok(())
}
```

### 1.6ã€main.rs
```js
mod cli;
mod commands;
mod database;
mod utils;

use clap::Parser;
use cli::{Cli, Commands};
use database::Database;

// cargo run add -h
fn main() {
    let args = Cli::parse();
    let mut db = Database::open();

    // åŒ¹é…å‘½ä»¤
    let result = match args.command {
        Commands::Info => commands::info(),
        Commands::Add { content } => commands::add(&mut db, content),
        Commands::Remove { id } => commands::remove(&mut db, id),
        Commands::List => commands::list(&mut db),
    };

    // ç»Ÿä¸€å¤„ç†é”™è¯¯
    if let Err(err) = result {
        eprintln!("\x1b[31merror:\x1b[39m {}", err);
        std::process::exit(1);
    }
}
```

### 1.7ã€å®‰è£…ä½¿ç”¨
å®‰è£…
```shell
cargo install
```

ä½¿ç”¨
```shell
todo-list add -h
```

## 2ã€grep from file
### 2.1ã€lib.rs
```js
use std::{env, error, fs};

#[derive(Debug)]
pub struct Config {
  pub query: String, // æŸ¥è¯¢å…³é”®è¯
  pub filename: String, // æ–‡ä»¶å
  pub case_sensitive: bool // æ˜¯å¦åŒºåˆ†å¤§å°å†™ï¼Œé»˜è®¤åŒºåˆ†
}

impl Config {
    pub fn new(args: &[String]) -> Result<Config, &'static str> {
        if args.len() < 3 {
            return Err("not enough arguments");
        }
        let query = args[1].clone();
        let filename = args[2].clone();
        let case_sensitive = env::var("CASE_INSENSITIVE").is_err();
        Ok(Config { query, filename, case_sensitive })
    }
}

pub fn run(config: Config) -> Result<(), Box<dyn error::Error>> {
    let contents = fs::read_to_string(config.filename)?;
    let result;
    if config.case_sensitive {
        result = search(&config.query, &contents)
    } else {
        result = search_case_insensitive(&config.query, &contents)
    }
    for line in result {
        println!("{}", line);
    }
    Ok(())
}

// åŒºåˆ†å¤§å°å†™
pub fn search<'a>(query: &'a str, contents: &'a str) -> Vec<&'a str> {
    let mut results = Vec::new();
    for line in contents.lines() {
        if line.contains(query) {
            results.push(line);
        }
    }
    results
}

// å¿½ç•¥å¤§å°å†™
pub fn search_case_insensitive<'a>(query: &'a str, contents: &'a str) -> Vec<&'a str> {
  let mut results = Vec::new();
  let query = query.to_lowercase();
  for line in contents.lines() {
      if line.to_lowercase().contains(&query) {
          results.push(line);
      }
  }
  results
}
```

### 2.2ã€main.rs
```js
use std::{env, process};
use grep_cli::{Config, run};

fn main() {
    let args: Vec<String> = env::args().collect();
    let config = Config::new(&args).unwrap_or_else(|err| {
        eprintln!("Problem parsing arguments: {}", err);
        process::exit(1);
    });
    if let Err(e) = run(config) {
      eprintln!("Application error: {}", e);
      process::exit(1);
    }
}
```

## 3ã€CaCher(ç¼“å­˜, æœ‰é—®é¢˜)
```js
struct CaCher<T,>
where
    T: Fn(u32) -> u32,
{
    cb: T,
    value: Option<u32>,
}

impl<T> CaCher<T>
where
    T: Fn(u32) -> u32,
{
    fn new(cb: T) -> Self {
        Self {
            cb,
            value: None,
        }
    }

    fn value(&mut self, arg: u32) -> u32 {
        match self.value {
            Some(v) => v,
            None => {
                let v = (self.cb)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}

fn main() {
  let mut cacher = CaCher::new(|num| {
    num + 1
  });
  let result = cacher.value(1);
  let result2 = cacher.value(2);
  println!("{}-{}", result, result2);
}
```

## 4ã€åšå®¢å‘å¸ƒ
```js
pub struct Post {
    state: Option<Box<dyn State>>,
    content: String,
}

impl Post {
    pub fn new() -> Post {
        Post {
            state: Some(Box::new(Draft {})),
            content: String::new(),
        }
    }
    pub fn add_text(&mut self, text: &str) {
        self.content.push_str(text);
    }
    pub fn content(&self) -> &str {
        self.state.as_ref().unwrap().content(self)
    }
    pub fn request_review(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.request_review())
        }
    }
    pub fn approve(&mut self) {
        if let Some(s) = self.state.take() {
            self.state = Some(s.approve())
        }
    }
}

trait State {
    fn request_review(self: Box<Self>) -> Box<dyn State>;
    fn approve(self: Box<Self>) -> Box<dyn State>;
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        ""
    }
}

struct Draft {}

impl State for Draft {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        Box::new(PendingReview {})
    }
    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
}

struct PendingReview {}

impl State for PendingReview {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }
    fn approve(self: Box<Self>) -> Box<dyn State> {
        Box::new(Published {})
    }
}

struct Published {}

impl State for Published {
    fn request_review(self: Box<Self>) -> Box<dyn State> {
        self
    }
    fn approve(self: Box<Self>) -> Box<dyn State> {
        self
    }
    fn content<'a>(&self, post: &'a Post) -> &'a str {
        &post.content
    }
}

pub fn generate_post() -> Post {
    Post::new()
}

#[cfg(test)]
mod tests {
    use super::*;
    #[test]
    fn post() {
        let mut post = generate_post();
        post.add_text("I ate a salad for lunch today");
        post.request_review();
        post.approve();
        assert_eq!("I ate a salad for lunch today", post.content());
    }
}
```

## 5ã€è¿›åº¦æ¡
```js
use std::io::{stdout, Result, Write};
use std::time::Duration;
use std::thread::sleep;

fn main() -> Result<()> {
    const BAR_LAB: &str = "-\\|/";
    for per in 0..101 {
            print!("\r {} \u{1b}[42m{}\u{1b}[0m [ {}% ] ", 
            BAR_LAB.chars().nth(per % 4).unwrap(), 
            " ".repeat(per / 2), 
            per
        );
        stdout().flush()?;
        sleep(Duration::from_micros(60_000));
    }
    println!();
    Ok(())
}
```

## 6ã€è½¬json
### 6.1ã€å­—ç¬¦ä¸²è½¬json
```js
use serde_json::Value;

fn main() {
    let json = r#"
    {
      "article": "how to work with json in Rust",
      "author": "tdep",
      "paragraph": [
        {
          "name": "untyped"
        },
        {
          "name": "strongly typed"
        },
        {
          "name": "writing json"
        }
      ]
    }
    "#;
    let parsed: Value = serde_json::from_str(json).unwrap();
    println!("{}-{}", parsed, parsed["article"]);
}
```

### 6.2ã€å­—ç¬¦ä¸²è½¬ç»“æ„ä½“
```js
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct Paragraph {
    name: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct Article {
    article: String,
    author: String,
    paragraph: Vec<Paragraph>,
}

fn main() {
    let json = r#"
    {
      "article": "how to work with json in Rust",
      "author": "tdep",
      "paragraph": [
        {
          "name": "untyped"
        },
        {
          "name": "strongly typed"
        },
        {
          "name": "writing json"
        }
      ]
    }
    "#;
    let parsed: Article = serde_json::from_str(json).unwrap();
    println!("{:?}", parsed);
}
```

### 6.3ã€ç»“æ„ä½“è½¬å­—ç¬¦ä¸²
```js
use serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug)]
struct Paragraph {
    name: String,
}

#[derive(Serialize, Deserialize, Debug)]
struct Article {
    article: String,
    author: String,
    paragraph: Vec<Paragraph>,
}

fn main() {
    let article: Article = Article {
        article: String::from("article name"),
        author: String::from("author name"),
        paragraph: vec![
            Paragraph {
                name: String::from("paragraph 1")
            },
            Paragraph {
                name: String::from("paragraph 2")
            }
        ],
    };
    let json = serde_json::to_string(&article).unwrap();
    println!("{}", json);
}
```